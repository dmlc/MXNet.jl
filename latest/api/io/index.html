



<!DOCTYPE html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      <meta http-equiv="x-ua-compatible" content="ie=edge">
      
      
      
      
        <meta name="lang:clipboard.copy" content="Copy to clipboard">
      
        <meta name="lang:clipboard.copied" content="Copied to clipboard">
      
        <meta name="lang:search.language" content="en">
      
        <meta name="lang:search.result.none" content="No matching documents">
      
        <meta name="lang:search.result.one" content="1 matching document">
      
        <meta name="lang:search.result.other" content="# matching documents">
      
        <meta name="lang:search.tokenizer" content="[\s\-]+">
      
      <link rel="shortcut icon" href="../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-0.17.2, mkdocs-material-2.1.0">
    
    
      
        <title>Data Providers - MXNet.jl</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/application-3368aa6b74.css">
      
    
    
      <script src="../../assets/javascripts/modernizr-e826f8942a.js"></script>
    
    
      
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700|Roboto+Mono">
        <style>body,input{font-family:"Roboto","Helvetica Neue",Helvetica,Arial,sans-serif}code,kbd,pre{font-family:"Roboto Mono","Courier New",Courier,monospace}</style>
      
      <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons">
    
    
      <link rel="stylesheet" href="../../assets/Documenter.css">
    
    
  </head>
  
    <body>
  
    <svg class="md-svg">
      <defs>
        
        
          <svg xmlns="http://www.w3.org/2000/svg" width="416" height="448" viewBox="0 0 416 448" id="github"><path fill="currentColor" d="M160 304q0 10-3.125 20.5t-10.75 19T128 352t-18.125-8.5-10.75-19T96 304t3.125-20.5 10.75-19T128 256t18.125 8.5 10.75 19T160 304zm160 0q0 10-3.125 20.5t-10.75 19T288 352t-18.125-8.5-10.75-19T256 304t3.125-20.5 10.75-19T288 256t18.125 8.5 10.75 19T320 304zm40 0q0-30-17.25-51T296 232q-10.25 0-48.75 5.25Q229.5 240 208 240t-39.25-2.75Q130.75 232 120 232q-29.5 0-46.75 21T56 304q0 22 8 38.375t20.25 25.75 30.5 15 35 7.375 37.25 1.75h42q20.5 0 37.25-1.75t35-7.375 30.5-15 20.25-25.75T360 304zm56-44q0 51.75-15.25 82.75-9.5 19.25-26.375 33.25t-35.25 21.5-42.5 11.875-42.875 5.5T212 416q-19.5 0-35.5-.75t-36.875-3.125-38.125-7.5-34.25-12.875T37 371.5t-21.5-28.75Q0 312 0 260q0-59.25 34-99-6.75-20.5-6.75-42.5 0-29 12.75-54.5 27 0 47.5 9.875t47.25 30.875Q171.5 96 212 96q37 0 70 8 26.25-20.5 46.75-30.25T376 64q12.75 25.5 12.75 54.5 0 21.75-6.75 42 34 40 34 99.5z"/></svg>
        
      </defs>
    </svg>
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="drawer">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="search">
    <label class="md-overlay" data-md-component="overlay" for="drawer"></label>
    
      <header class="md-header" data-md-component="header">
  <nav class="md-header-nav md-grid">
    <div class="md-flex">
      <div class="md-flex__cell md-flex__cell--shrink">
        <a href="../.." title="MXNet.jl" class="md-header-nav__button md-logo">
          
            <i class="md-icon"></i>
          
        </a>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        <label class="md-icon md-icon--menu md-header-nav__button" for="drawer"></label>
      </div>
      <div class="md-flex__cell md-flex__cell--stretch">
        <div class="md-flex__ellipsis md-header-nav__title" data-md-component="title">
          
            
              <span class="md-header-nav__topic">
                MXNet.jl
              </span>
              <span class="md-header-nav__topic">
                Data Providers
              </span>
            
          
        </div>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        
          
            <label class="md-icon md-icon--search md-header-nav__button" for="search"></label>
            
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="search"></label>
  <div class="md-search__inner">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" required placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="query">
      <label class="md-icon md-search__icon" for="search"></label>
      <button type="reset" class="md-icon md-search__icon" data-md-component="reset">&#xE5CD;</button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="result">
          <div class="md-search-result__meta">
            Type to start searching
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
          
        
      </div>
      
        <div class="md-flex__cell md-flex__cell--shrink">
          <div class="md-header-nav__source">
            


  


  <a href="https://github.com/dmlc/MXNet.jl/" title="Go to repository" class="md-source" data-md-source="github">
    
      <div class="md-source__icon">
        <svg viewBox="0 0 24 24" width="24" height="24">
          <use xlink:href="#github" width="24" height="24"></use>
        </svg>
      </div>
    
    <div class="md-source__repository">
      GitHub
    </div>
  </a>

          </div>
        </div>
      
    </div>
  </nav>
</header>
    
    <div class="md-container">
      
      <main class="md-main">
        <div class="md-main__inner md-grid" data-md-component="container">
          
            
              <div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    <nav class="md-nav md-nav--primary" data-md-level="0">
  <label class="md-nav__title md-nav__title--site" for="drawer">
    <span class="md-nav__button md-logo">
      
        <i class="md-icon"></i>
      
    </span>
    MXNet.jl
  </label>
  
    <div class="md-nav__source">
      


  


  <a href="https://github.com/dmlc/MXNet.jl/" title="Go to repository" class="md-source" data-md-source="github">
    
      <div class="md-source__icon">
        <svg viewBox="0 0 24 24" width="24" height="24">
          <use xlink:href="#github" width="24" height="24"></use>
        </svg>
      </div>
    
    <div class="md-source__repository">
      GitHub
    </div>
  </a>

    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      


  <li class="md-nav__item">
    <a href="../.." title="Home" class="md-nav__link">
      Home
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-2" type="checkbox" id="nav-2">
    
    <label class="md-nav__link" for="nav-2">
      Tutorial
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-2">
        Tutorial
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../tutorial/mnist/" title="Digit Recognition on MNIST" class="md-nav__link">
      Digit Recognition on MNIST
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../tutorial/char-lstm/" title="Generating Random Sentence with LSTM RNN" class="md-nav__link">
      Generating Random Sentence with LSTM RNN
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-3" type="checkbox" id="nav-3">
    
    <label class="md-nav__link" for="nav-3">
      User Guide
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-3">
        User Guide
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../user-guide/install/" title="Installation Guide" class="md-nav__link">
      Installation Guide
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../user-guide/overview/" title="Overview" class="md-nav__link">
      Overview
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../user-guide/faq/" title="FAQ" class="md-nav__link">
      FAQ
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      

  


  <li class="md-nav__item md-nav__item--active md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-4" type="checkbox" id="nav-4" checked>
    
    <label class="md-nav__link" for="nav-4">
      API Documentation
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-4">
        API Documentation
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../context/" title="Context" class="md-nav__link">
      Context
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../model/" title="Models" class="md-nav__link">
      Models
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../initializer/" title="Initializers" class="md-nav__link">
      Initializers
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../optimizer/" title="Optimizers" class="md-nav__link">
      Optimizers
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../callback/" title="Callbacks in training" class="md-nav__link">
      Callbacks in training
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../metric/" title="Evaluation Metrics" class="md-nav__link">
      Evaluation Metrics
    </a>
  </li>

        
          
          
          

  


  <li class="md-nav__item md-nav__item--active">
    
    <input class="md-toggle md-nav__toggle" data-md-toggle="toc" type="checkbox" id="toc">
    
      
    
    
      <label class="md-nav__link md-nav__link--active" for="toc">
        Data Providers
      </label>
    
    <a href="./" title="Data Providers" class="md-nav__link md-nav__link--active">
      Data Providers
    </a>
    
      
<nav class="md-nav md-nav--secondary">
  
  
    
  
  
    <label class="md-nav__title" for="toc">Table of contents</label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#abstractdataprovider-interface" title="AbstractDataProvider interface" class="md-nav__link">
    AbstractDataProvider interface
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#abstractdatabatch-interface" title="AbstractDataBatch interface" class="md-nav__link">
    AbstractDataBatch interface
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#implemented-providers-and-other-methods" title="Implemented providers and other methods" class="md-nav__link">
    Implemented providers and other methods
  </a>
  
</li>
      
      
      
    </ul>
  
</nav>
    
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../ndarray/" title="NDArray API" class="md-nav__link">
      NDArray API
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../symbolic-node/" title="Symbolic API" class="md-nav__link">
      Symbolic API
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../nn-factory/" title="Neural Networks Factory" class="md-nav__link">
      Neural Networks Factory
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../executor/" title="Executor" class="md-nav__link">
      Executor
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../visualize/" title="Network Visualization" class="md-nav__link">
      Network Visualization
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              <div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    
<nav class="md-nav md-nav--secondary">
  
  
    
  
  
    <label class="md-nav__title" for="toc">Table of contents</label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#abstractdataprovider-interface" title="AbstractDataProvider interface" class="md-nav__link">
    AbstractDataProvider interface
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#abstractdatabatch-interface" title="AbstractDataBatch interface" class="md-nav__link">
    AbstractDataBatch interface
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#implemented-providers-and-other-methods" title="Implemented providers and other methods" class="md-nav__link">
    Implemented providers and other methods
  </a>
  
</li>
      
      
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content">
            <article class="md-content__inner md-typeset">
              
                
                  <a href="https://github.com/dmlc/MXNet.jl/edit/master/docs/api/io.md" title="Edit this page" class="md-icon md-content__icon">&#xE3C9;</a>
                
                
                <p><a id='Data-Providers-1'></a></p>
<h1 id="data-providers">Data Providers</h1>
<p>Data providers are wrappers that load external data, be it images, text, or general tensors, and split it into mini-batches so that the model can consume the data in a uniformed way.</p>
<p><a id='AbstractDataProvider-interface-1'></a></p>
<h2 id="abstractdataprovider-interface">AbstractDataProvider interface</h2>
<p><a id='MXNet.mx.AbstractDataProvider' href='#MXNet.mx.AbstractDataProvider'>#</a>
<strong><code>MXNet.mx.AbstractDataProvider</code></strong> &mdash; <em>Type</em>.</p>
<pre><code>AbstractDataProvider
</code></pre>

<p>The root type for all data provider. A data provider should implement the following interfaces:</p>
<ul>
<li><a href="./#MXNet.mx.get_batch_size"><code>get_batch_size</code></a></li>
<li><a href="./#MXNet.mx.provide_data"><code>provide_data</code></a></li>
<li><a href="./#MXNet.mx.provide_label"><code>provide_label</code></a></li>
</ul>
<p>As well as the Julia iterator interface (see <a href="http://docs.julialang.org/en/stable/manual/interfaces/">the Julia manual</a>). Normally this involves defining:</p>
<ul>
<li><code>Base.eltype(provider) -&gt; AbstractDataBatch</code></li>
<li><code>Base.start(provider) -&gt; AbstractDataProviderState</code></li>
<li><code>Base.done(provider, state) -&gt; Bool</code></li>
<li><code>Base.next(provider, state) -&gt; (AbstractDataBatch, AbstractDataProvider)</code></li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/1f50a144c90e5034af79468b0c9a9ff234a11b98/src/io.jl#L1-L17' class='documenter-source'>source</a><br></p>
<p>The difference between <em>data</em> and <em>label</em> is that during training stage, both <em>data</em> and <em>label</em> will be feeded into the model, while during prediction stage, only <em>data</em> is loaded. Otherwise, they could be anything, with any names, and of any shapes. The provided data and label names here should match the input names in a target <code>SymbolicNode</code>.</p>
<p>A data provider should also implement the Julia iteration interface, in order to allow iterating through the data set. The provider will be called in the following way:</p>
<pre><code class="julia">for batch in eachbatch(provider)
    data = get_data(provider, batch)
end
</code></pre>

<p>which will be translated by Julia compiler into</p>
<pre><code class="julia">state = Base.start(eachbatch(provider))
while !Base.done(provider, state)
    (batch, state) = Base.next(provider, state)
    data = get_data(provider, batch)
end
</code></pre>

<p>By default, <code>eachbatch</code> simply returns the provider itself, so the iterator interface is implemented on the provider type itself. But the extra layer of abstraction allows us to implement a data provider easily via a Julia <code>Task</code> coroutine. See the data provider defined in <a href="../tutorial/char-lstm">the char-lstm example</a> for an example of using coroutine to define data providers.</p>
<p>The detailed interface functions for the iterator API is listed below:</p>
<pre><code>Base.eltype(provider) -&gt; AbstractDataBatch
</code></pre>

<p>Returns the specific subtype representing a data batch. See <code>AbstractDataBatch</code>.</p>
<ul>
<li>
<p><code>provider::AbstractDataProvider</code>: the data provider.</p>
<p>Base.start(provider) -&gt; AbstractDataProviderState</p>
</li>
</ul>
<p>This function is always called before iterating into the dataset. It should initialize the iterator, reset the index, and do data shuffling if needed.</p>
<ul>
<li>
<p><code>provider::AbstractDataProvider</code>: the data provider.</p>
<p>Base.done(provider, state) -&gt; Bool</p>
</li>
</ul>
<p>True if there is no more data to iterate in this dataset.</p>
<ul>
<li><code>provider::AbstractDataProvider</code>: the data provider.</li>
<li>
<p><code>state::AbstractDataProviderState</code>: the state returned by <code>Base.start</code> and <code>Base.next</code>.</p>
<p>Base.next(provider) -&gt; (AbstractDataBatch, AbstractDataProviderState)</p>
</li>
</ul>
<p>Returns the current data batch, and the state for the next iteration.</p>
<ul>
<li><code>provider::AbstractDataProvider</code>: the data provider.</li>
</ul>
<p>Note sometimes you are wrapping an existing data iterator (e.g. the built-in libmxnet data iterator) that is built with a different convention. It might be difficult to adapt to the interfaces stated here. In this case, you can safely assume that</p>
<ul>
<li><code>Base.start</code> will always be called, and called only once before the iteration starts.</li>
<li><code>Base.done</code> will always be called at the beginning of every iteration and always be called once.</li>
<li>If <code>Base.done</code> return true, the iteration will stop, until the next round, again, starting with a call to <code>Base.start</code>.</li>
<li><code>Base.next</code> will always be called only once in each iteration. It will always be called after one and only one call to <code>Base.done</code>; but if <code>Base.done</code> returns true, <code>Base.next</code> will not be called.</li>
</ul>
<p>With those assumptions, it will be relatively easy to adapt any existing iterator. See the implementation of the built-in <code>MXDataProvider</code> for example.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Please do not use the one data provider simultaneously in two different places, either in parallel, or in a nested loop. For example, the behavior for the following code is undefined</p>
<p>```julia
for batch in data
    # updating the parameters</p>
<pre><code># now let's test the performance on the training set
for b2 in data
    # ...
end
</code></pre>
<p>end
```</p>
</div>
<p><a id='MXNet.mx.get_batch_size' href='#MXNet.mx.get_batch_size'>#</a>
<strong><code>MXNet.mx.get_batch_size</code></strong> &mdash; <em>Function</em>.</p>
<pre><code>get_batch_size(provider) -&gt; Int
</code></pre>

<p><strong>Arguments:</strong></p>
<ul>
<li><code>provider::AbstractDataProvider</code>: the data provider.</li>
</ul>
<p>Returns the mini-batch size of the provided data. All the provided data should have the same mini-batch size (i.e. the last dimension).</p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/1f50a144c90e5034af79468b0c9a9ff234a11b98/src/io.jl#L20-L27' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.provide_data' href='#MXNet.mx.provide_data'>#</a>
<strong><code>MXNet.mx.provide_data</code></strong> &mdash; <em>Function</em>.</p>
<pre><code>provide_data(provider) -&gt; Vector{Tuple{Base.Symbol, Tuple}}
</code></pre>

<p><strong>Arguments:</strong></p>
<ul>
<li><code>provider::AbstractDataProvider</code>: the data provider.</li>
</ul>
<p>Returns a vector of (name, shape) pairs describing the names of the data it provides, and the corresponding shapes.</p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/1f50a144c90e5034af79468b0c9a9ff234a11b98/src/io.jl#L30-L38' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.provide_label' href='#MXNet.mx.provide_label'>#</a>
<strong><code>MXNet.mx.provide_label</code></strong> &mdash; <em>Function</em>.</p>
<pre><code>provide_label(provider) -&gt; Vector{Tuple{Base.Symbol, Tuple}}
</code></pre>

<p><strong>Arguments:</strong></p>
<ul>
<li><code>provider::AbstractDataProvider</code>: the data provider.</li>
</ul>
<p>Returns a vector of (name, shape) pairs describing the names of the labels it provides, and the corresponding shapes.</p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/1f50a144c90e5034af79468b0c9a9ff234a11b98/src/io.jl#L41-L48' class='documenter-source'>source</a><br></p>
<p><a id='AbstractDataBatch-interface-1'></a></p>
<h2 id="abstractdatabatch-interface">AbstractDataBatch interface</h2>
<p><a id='MXNet.mx.AbstractDataProviderState' href='#MXNet.mx.AbstractDataProviderState'>#</a>
<strong><code>MXNet.mx.AbstractDataProviderState</code></strong> &mdash; <em>Type</em>.</p>
<pre><code>AbstractDataProviderState
</code></pre>

<p>Base type for data provider states.</p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/1f50a144c90e5034af79468b0c9a9ff234a11b98/src/io.jl#L51-L55' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.count_samples' href='#MXNet.mx.count_samples'>#</a>
<strong><code>MXNet.mx.count_samples</code></strong> &mdash; <em>Function</em>.</p>
<pre><code>count_samples(provider, batch) -&gt; Int
</code></pre>

<p><strong>Arguments:</strong></p>
<ul>
<li><code>batch::AbstractDataBatch</code>: the data batch object.</li>
</ul>
<p>Returns the number of samples in this batch. This number should be greater than 0, but less than or equal to the batch size. This is used to indicate at the end of the data set, there might not be enough samples for a whole mini-batch.</p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/1f50a144c90e5034af79468b0c9a9ff234a11b98/src/io.jl#L75-L83' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.get_data' href='#MXNet.mx.get_data'>#</a>
<strong><code>MXNet.mx.get_data</code></strong> &mdash; <em>Function</em>.</p>
<pre><code>get_data(provider, batch) -&gt; Vector{NDArray}
</code></pre>

<p><strong>Arguments:</strong></p>
<ul>
<li><code>provider::AbstractDataProvider</code>: the data provider.</li>
<li><code>batch::AbstractDataBatch</code>: the data batch object.</li>
</ul>
<p>Returns a vector of data in this batch, should be in the same order as declared in <code>provide_data() &lt;AbstractDataProvider.provide_data&gt;</code>.</p>
<p>The last dimension of each <code>NDArray</code> should always match the batch_size, even when <code>count_samples</code> returns a value less than the batch size. In this case,      the data provider is free to pad the remaining contents with any value.</p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/1f50a144c90e5034af79468b0c9a9ff234a11b98/src/io.jl#L86-L96' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.get_label' href='#MXNet.mx.get_label'>#</a>
<strong><code>MXNet.mx.get_label</code></strong> &mdash; <em>Function</em>.</p>
<pre><code>get_label(provider, batch) -&gt; Vector{NDArray}
</code></pre>

<p><strong>Arguments:</strong></p>
<ul>
<li><code>provider::AbstractDataProvider</code>: the data provider.</li>
<li><code>batch::AbstractDataBatch</code>: the data batch object.</li>
</ul>
<p>Returns a vector of labels in this batch. Similar to <a href="./#MXNet.mx.get_data"><code>get_data</code></a>.</p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/1f50a144c90e5034af79468b0c9a9ff234a11b98/src/io.jl#L99-L107' class='documenter-source'>source</a><br></p>
<p><a id='Base.get' href='#Base.get'>#</a>
<strong><code>Base.get</code></strong> &mdash; <em>Function</em>.</p>
<pre><code>get(metric)
</code></pre>

<p>Get the accumulated metrics.</p>
<p>Returns <code>Vector{Tuple{Base.Symbol, Real}}</code>, a list of name-value pairs. For example, <code>[(:accuracy, 0.9)]</code>.</p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/1f50a144c90e5034af79468b0c9a9ff234a11b98/src/metric.jl#L74-L81' class='documenter-source'>source</a><br></p>
<pre><code>get(provider, batch, name) -&gt; NDArray
</code></pre>

<ul>
<li><code>provider::AbstractDataProvider</code>: the data provider.</li>
<li><code>batch::AbstractDataBatch</code>: the data batch object.</li>
<li><code>name::Symbol</code>: the name of the data to get, should be one of the names provided in either <code>provide_data() &lt;AbstractDataProvider.provide_data&gt;</code> or <code>provide_label() &lt;AbstractDataProvider.provide_label&gt;</code>.</li>
</ul>
<p>Returns the corresponding data array corresponding to that name.</p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/1f50a144c90e5034af79468b0c9a9ff234a11b98/src/io.jl#L190-L200' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.load_data!' href='#MXNet.mx.load_data!'>#</a>
<strong><code>MXNet.mx.load_data!</code></strong> &mdash; <em>Function</em>.</p>
<pre><code>load_data!(provider, batch, targets)
</code></pre>

<p><strong>Arguments:</strong></p>
<ul>
<li><code>provider::AbstractDataProvider</code>: the data provider.</li>
<li><code>batch::AbstractDataBatch</code>: the data batch object.</li>
<li><code>targets::Vector{Vector{SlicedNDArray}}</code>: the targets to load data into.</li>
</ul>
<p>The targets is a list of the same length as number of data provided by this provider. Each element in the list is a list of <code>SlicedNDArray</code>. This list described a spliting scheme of this data batch into different slices, each slice is specified by a slice-ndarray pair, where <em>slice</em> specify the range of samples in the mini-batch that should be loaded into the corresponding <em>ndarray</em>.</p>
<p>This utility function is used in data parallelization, where a mini-batch is splited and computed on several different devices.</p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/1f50a144c90e5034af79468b0c9a9ff234a11b98/src/io.jl#L142-L158' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.load_label!' href='#MXNet.mx.load_label!'>#</a>
<strong><code>MXNet.mx.load_label!</code></strong> &mdash; <em>Function</em>.</p>
<pre><code>load_label!(provider, batch, targets)
</code></pre>

<ul>
<li><code>provider::AbstractDataProvider provider</code>: the data provider.</li>
<li><code>batch::AbstractDataBatch batch</code>: the data batch object.</li>
<li><code>targets::Vector{Vector{SlicedNDArray}}</code>: the targets to load label into.</li>
</ul>
<p>The same as <a href="./#MXNet.mx.load_data!"><code>load_data!</code></a>, except that this is for loading labels.</p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/1f50a144c90e5034af79468b0c9a9ff234a11b98/src/io.jl#L164-L172' class='documenter-source'>source</a><br></p>
<p><a id='Implemented-providers-and-other-methods-1'></a></p>
<h2 id="implemented-providers-and-other-methods">Implemented providers and other methods</h2>
<p><a id='MXNet.mx.AbstractDataBatch' href='#MXNet.mx.AbstractDataBatch'>#</a>
<strong><code>MXNet.mx.AbstractDataBatch</code></strong> &mdash; <em>Type</em>.</p>
<pre><code>AbstractDataBatch
</code></pre>

<p>Base type for a data mini-batch. It should implement the following interfaces:</p>
<ul>
<li><a href="./#MXNet.mx.count_samples"><code>count_samples</code></a></li>
<li><a href="./#MXNet.mx.get_data"><code>get_data</code></a></li>
<li><a href="./#MXNet.mx.get_label"><code>get_label</code></a></li>
</ul>
<p>The following utility functions will be automatically defined:</p>
<ul>
<li><a href="./#Base.get"><code>get</code></a></li>
<li><a href="./#MXNet.mx.load_data!"><code>load_data!</code></a></li>
<li><a href="./#MXNet.mx.load_label!"><code>load_label!</code></a></li>
</ul>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/1f50a144c90e5034af79468b0c9a9ff234a11b98/src/io.jl#L58-L72' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.ArrayDataProvider' href='#MXNet.mx.ArrayDataProvider'>#</a>
<strong><code>MXNet.mx.ArrayDataProvider</code></strong> &mdash; <em>Type</em>.</p>
<pre><code>ArrayDataProvider
</code></pre>

<p>A convenient tool to iterate <code>NDArray</code> or Julia <code>Array</code>.</p>
<pre><code>ArrayDataProvider(data[, label]; batch_size, shuffle, data_padding, label_padding)
</code></pre>

<p>Construct a data provider from <code>NDArray</code> or Julia Arrays.</p>
<p><strong>Arguments:</strong></p>
<ul>
<li>
<p><code>data</code>: the data, could be</p>
<ul>
<li>a <code>NDArray</code>, or a Julia Array. This is equivalent to <code>:data =&gt; data</code>.</li>
<li>a name-data pair, like <code>:mydata =&gt; array</code>, where <code>:mydata</code> is the name of the data</li>
<li>and <code>array</code> is an <code>NDArray</code> or a Julia Array.</li>
<li>a list of name-data pairs.</li>
<li><code>label</code>: the same as the <code>data</code> parameter. When this argument is omitted, the constructed provider will provide no labels.</li>
<li><code>batch_size::Int</code>: the batch size, default is 0, which means treating the whole array as a single mini-batch.</li>
<li><code>shuffle::Bool</code>: turn on if the data should be shuffled at every epoch.</li>
<li><code>data_padding::Real</code>: when the mini-batch goes beyond the dataset boundary, there might be less samples to include than a mini-batch. This value specify a scalar to pad the contents of all the missing data points.</li>
<li><code>label_padding::Real</code>: the same as <code>data_padding</code>, except for the labels.</li>
</ul>
</li>
</ul>
<p>TODO: remove <code>data_padding</code> and <code>label_padding</code>, and implement rollover that copies the last or first several training samples to feed the padding.</p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/1f50a144c90e5034af79468b0c9a9ff234a11b98/src/io.jl#L228-L254' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.DataBatch' href='#MXNet.mx.DataBatch'>#</a>
<strong><code>MXNet.mx.DataBatch</code></strong> &mdash; <em>Type</em>.</p>
<pre><code>DataBatch
</code></pre>

<p>A basic subclass of <code>AbstractDataBatch</code>, that implement the interface by accessing member fields.</p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/1f50a144c90e5034af79468b0c9a9ff234a11b98/src/io.jl#L110-L115' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.MXDataProvider' href='#MXNet.mx.MXDataProvider'>#</a>
<strong><code>MXNet.mx.MXDataProvider</code></strong> &mdash; <em>Type</em>.</p>
<pre><code>MXDataProvider
</code></pre>

<p>A data provider that wrap built-in data iterators from libmxnet. See below for a list of built-in data iterators.</p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/1f50a144c90e5034af79468b0c9a9ff234a11b98/src/io.jl#L420-L425' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.SlicedNDArray' href='#MXNet.mx.SlicedNDArray'>#</a>
<strong><code>MXNet.mx.SlicedNDArray</code></strong> &mdash; <em>Type</em>.</p>
<pre><code>SlicedNDArray
</code></pre>

<p>A alias type of <code>Tuple{UnitRange{Int},NDArray}</code>.</p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/1f50a144c90e5034af79468b0c9a9ff234a11b98/src/io.jl#L125-L129' class='documenter-source'>source</a><br></p>
<p><a id='Base.get-Tuple{MXNet.mx.AbstractDataProvider,MXNet.mx.AbstractDataBatch,Symbol}' href='#Base.get-Tuple{MXNet.mx.AbstractDataProvider,MXNet.mx.AbstractDataBatch,Symbol}'>#</a>
<strong><code>Base.get</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>get(provider, batch, name) -&gt; NDArray
</code></pre>

<ul>
<li><code>provider::AbstractDataProvider</code>: the data provider.</li>
<li><code>batch::AbstractDataBatch</code>: the data batch object.</li>
<li><code>name::Symbol</code>: the name of the data to get, should be one of the names provided in either <code>provide_data() &lt;AbstractDataProvider.provide_data&gt;</code> or <code>provide_label() &lt;AbstractDataProvider.provide_label&gt;</code>.</li>
</ul>
<p>Returns the corresponding data array corresponding to that name.</p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/1f50a144c90e5034af79468b0c9a9ff234a11b98/src/io.jl#L190-L200' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.CSVIter-Tuple{}' href='#MXNet.mx.CSVIter-Tuple{}'>#</a>
<strong><code>MXNet.mx.CSVIter</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>CSVIter(data_csv, data_shape, label_csv, label_shape, batch_size, round_batch, prefetch_buffer, dtype)
</code></pre>

<p>Can also be called with the alias <code>CSVProvider</code>. Returns the CSV file iterator.</p>
<p>In this function, the <code>data_shape</code> parameter is used to set the shape of each line of the input data. If a row in an input file is <code>1,2,3,4,5,6``and</code>data_shape` is (3,2), that row will be reshaped, yielding the array [[1,2],[3,4],[5,6]] of shape (3,2).</p>
<p>By default, the <code>CSVIter</code> has <code>round_batch</code> parameter set to $True$. So, if <code>batch_size</code> is 3 and there are 4 total rows in CSV file, 2 more examples are consumed at the first round. If <code>reset</code> function is called after first round, the call is ignored and remaining examples are returned in the second round.</p>
<p>If one wants all the instances in the second round after calling <code>reset</code>, make sure to set <code>round_batch</code> to False.</p>
<p>If $data_csv = 'data/'$ is set, then all the files in this directory will be read.</p>
<p>$reset()$ is expected to be called only after a complete pass of data.</p>
<p>Examples::</p>
<p>// Contents of CSV file $data/data.csv$.   1,2,3   2,3,4   3,4,5   4,5,6</p>
<p>// Creates a <code>CSVIter</code> with <code>batch_size</code>=2 and default <code>round_batch</code>=True.   CSVIter = mx.io.CSVIter(data_csv = 'data/data.csv', data_shape = (3,),   batch_size = 2)</p>
<p>// Two batches read from the above iterator are as follows:   [[ 1.  2.  3.]   [ 2.  3.  4.]]   [[ 3.  4.  5.]   [ 4.  5.  6.]]</p>
<p>// Creates a <code>CSVIter</code> with default <code>round_batch</code> set to True.   CSVIter = mx.io.CSVIter(data_csv = 'data/data.csv', data_shape = (3,),   batch_size = 3)</p>
<p>// Two batches read from the above iterator in the first pass are as follows:   [[1.  2.  3.]   [2.  3.  4.]   [3.  4.  5.]]</p>
<p>[[4.  5.  6.]   [1.  2.  3.]   [2.  3.  4.]]</p>
<p>// Now, <code>reset</code> method is called.   CSVIter.reset()</p>
<p>// Batch read from the above iterator in the second pass is as follows:   [[ 3.  4.  5.]   [ 4.  5.  6.]   [ 1.  2.  3.]]</p>
<p>// Creates a <code>CSVIter</code> with <code>round_batch</code>=False.   CSVIter = mx.io.CSVIter(data_csv = 'data/data.csv', data_shape = (3,),   batch_size = 3, round_batch=False)</p>
<p>// Contents of two batches read from the above iterator in both passes, after calling   // <code>reset</code> method before second pass, is as follows:   [[1.  2.  3.]   [2.  3.  4.]   [3.  4.  5.]]</p>
<p>[[4.  5.  6.]   [2.  3.  4.]   [3.  4.  5.]]</p>
<p>Defined in src/io/iter_csv.cc:L223</p>
<p><strong>Arguments:</strong></p>
<ul>
<li><code>data_name::Symbol</code>: keyword argument, default <code>:data</code>. The name of the data.</li>
<li><code>label_name::Symbol</code>: keyword argument, default <code>:softmax_label</code>. The name of the label. Could be <code>nothing</code> if no label is presented in this dataset.</li>
<li><code>data_csv::string, required</code>: The input CSV file or a directory path.</li>
<li><code>data_shape::Shape(tuple), required</code>: The shape of one example.</li>
<li><code>label_csv::string, optional, default='NULL'</code>: The input CSV file or a directory path. If NULL, all labels will be returned as 0.</li>
<li><code>label_shape::Shape(tuple), optional, default=[1]</code>: The shape of one label.</li>
<li><code>batch_size::int (non-negative), required</code>: Batch size.</li>
<li><code>round_batch::boolean, optional, default=1</code>: Whether to use round robin to handle overflow batch or not.</li>
<li><code>prefetch_buffer::long (non-negative), optional, default=4</code>: Maximum number of batches to prefetch.</li>
<li><code>dtype::{None, 'float16', 'float32', 'float64', 'int32', 'uint8'},optional, default='None'</code>: Output data type. $None$ means no change.</li>
</ul>
<p>Returns the constructed <code>MXDataProvider</code>.</p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/1f50a144c90e5034af79468b0c9a9ff234a11b98/src/io.jl#L619-L718' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.ImageDetRecordIter-Tuple{}' href='#MXNet.mx.ImageDetRecordIter-Tuple{}'>#</a>
<strong><code>MXNet.mx.ImageDetRecordIter</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>ImageDetRecordIter(path_imglist, path_imgrec, aug_seq, label_width, data_shape, preprocess_threads, verbose, num_parts, part_index, shuffle_chunk_size, shuffle_chunk_seed, label_pad_width, label_pad_value, shuffle, seed, verbose, batch_size, round_batch, prefetch_buffer, dtype, resize, rand_crop_prob, min_crop_scales, max_crop_scales, min_crop_aspect_ratios, max_crop_aspect_ratios, min_crop_overlaps, max_crop_overlaps, min_crop_sample_coverages, max_crop_sample_coverages, min_crop_object_coverages, max_crop_object_coverages, num_crop_sampler, crop_emit_mode, emit_overlap_thresh, max_crop_trials, rand_pad_prob, max_pad_scale, max_random_hue, random_hue_prob, max_random_saturation, random_saturation_prob, max_random_illumination, random_illumination_prob, max_random_contrast, random_contrast_prob, rand_mirror_prob, fill_value, inter_method, data_shape, resize_mode, seed, mean_img, mean_r, mean_g, mean_b, mean_a, std_r, std_g, std_b, std_a, scale, verbose)
</code></pre>

<p>Can also be called with the alias <code>ImageDetRecordProvider</code>. Create iterator for image detection dataset packed in recordio.</p>
<p><strong>Arguments:</strong></p>
<ul>
<li><code>data_name::Symbol</code>: keyword argument, default <code>:data</code>. The name of the data.</li>
<li><code>label_name::Symbol</code>: keyword argument, default <code>:softmax_label</code>. The name of the label. Could be <code>nothing</code> if no label is presented in this dataset.</li>
<li><code>path_imglist::string, optional, default=''</code>: Dataset Param: Path to image list.</li>
<li><code>path_imgrec::string, optional, default='./data/imgrec.rec'</code>: Dataset Param: Path to image record file.</li>
<li><code>aug_seq::string, optional, default='det_aug_default'</code>: Augmentation Param: the augmenter names to represent sequence of augmenters to be applied, seperated by comma. Additional keyword parameters will be seen by these augmenters. Make sure you don't use normal augmenters for detection tasks.</li>
<li><code>label_width::int, optional, default='-1'</code>: Dataset Param: How many labels for an image, -1 for variable label size.</li>
<li><code>data_shape::Shape(tuple), required</code>: Dataset Param: Shape of each instance generated by the DataIter.</li>
<li><code>preprocess_threads::int, optional, default='4'</code>: Backend Param: Number of thread to do preprocessing.</li>
<li><code>verbose::boolean, optional, default=1</code>: Auxiliary Param: Whether to output parser information.</li>
<li><code>num_parts::int, optional, default='1'</code>: partition the data into multiple parts</li>
<li><code>part_index::int, optional, default='0'</code>: the index of the part will read</li>
<li><code>shuffle_chunk_size::long (non-negative), optional, default=0</code>: the size(MB) of the shuffle chunk, used with shuffle=True, it can enable global shuffling</li>
<li><code>shuffle_chunk_seed::int, optional, default='0'</code>: the seed for chunk shuffling</li>
<li><code>label_pad_width::int, optional, default='0'</code>: pad output label width if set larger than 0, -1 for auto estimate</li>
<li><code>label_pad_value::float, optional, default=-1</code>: label padding value if enabled</li>
<li><code>shuffle::boolean, optional, default=0</code>: Augmentation Param: Whether to shuffle data.</li>
<li><code>seed::int, optional, default='0'</code>: Augmentation Param: Random Seed.</li>
<li><code>batch_size::int (non-negative), required</code>: Batch size.</li>
<li><code>round_batch::boolean, optional, default=1</code>: Whether to use round robin to handle overflow batch or not.</li>
<li><code>prefetch_buffer::long (non-negative), optional, default=4</code>: Maximum number of batches to prefetch.</li>
<li><code>dtype::{None, 'float16', 'float32', 'float64', 'int32', 'uint8'},optional, default='None'</code>: Output data type. $None$ means no change.</li>
<li><code>resize::int, optional, default='-1'</code>: Augmentation Param: scale shorter edge to size before applying other augmentations, -1 to disable.</li>
<li><code>rand_crop_prob::float, optional, default=0</code>: Augmentation Param: Probability of random cropping, &lt;= 0 to disable</li>
<li><code>min_crop_scales::tuple of &lt;float&gt;, optional, default=[0]</code>: Augmentation Param: Min crop scales.</li>
<li><code>max_crop_scales::tuple of &lt;float&gt;, optional, default=[1]</code>: Augmentation Param: Max crop scales.</li>
<li><code>min_crop_aspect_ratios::tuple of &lt;float&gt;, optional, default=[1]</code>: Augmentation Param: Min crop aspect ratios.</li>
<li><code>max_crop_aspect_ratios::tuple of &lt;float&gt;, optional, default=[1]</code>: Augmentation Param: Max crop aspect ratios.</li>
<li><code>min_crop_overlaps::tuple of &lt;float&gt;, optional, default=[0]</code>: Augmentation Param: Minimum crop IOU between crop_box and ground-truths.</li>
<li><code>max_crop_overlaps::tuple of &lt;float&gt;, optional, default=[1]</code>: Augmentation Param: Maximum crop IOU between crop_box and ground-truth.</li>
<li><code>min_crop_sample_coverages::tuple of &lt;float&gt;, optional, default=[0]</code>: Augmentation Param: Minimum ratio of intersect/crop_area between crop box and ground-truths.</li>
<li><code>max_crop_sample_coverages::tuple of &lt;float&gt;, optional, default=[1]</code>: Augmentation Param: Maximum ratio of intersect/crop_area between crop box and ground-truths.</li>
<li><code>min_crop_object_coverages::tuple of &lt;float&gt;, optional, default=[0]</code>: Augmentation Param: Minimum ratio of intersect/gt_area between crop box and ground-truths.</li>
<li><code>max_crop_object_coverages::tuple of &lt;float&gt;, optional, default=[1]</code>: Augmentation Param: Maximum ratio of intersect/gt_area between crop box and ground-truths.</li>
<li><code>num_crop_sampler::int, optional, default='1'</code>: Augmentation Param: Number of crop samplers.</li>
<li><code>crop_emit_mode::{'center', 'overlap'},optional, default='center'</code>: Augmentation Param: Emition mode for invalid ground-truths after crop. center: emit if centroid of object is out of crop region; overlap: emit if overlap is less than emit_overlap_thresh.</li>
<li><code>emit_overlap_thresh::float, optional, default=0.3</code>: Augmentation Param: Emit overlap thresh for emit mode overlap only.</li>
<li><code>max_crop_trials::Shape(tuple), optional, default=[25]</code>: Augmentation Param: Skip cropping if fail crop trail count exceeds this number.</li>
<li><code>rand_pad_prob::float, optional, default=0</code>: Augmentation Param: Probability for random padding.</li>
<li><code>max_pad_scale::float, optional, default=1</code>: Augmentation Param: Maximum padding scale.</li>
<li><code>max_random_hue::int, optional, default='0'</code>: Augmentation Param: Maximum random value of H channel in HSL color space.</li>
<li><code>random_hue_prob::float, optional, default=0</code>: Augmentation Param: Probability to apply random hue.</li>
<li><code>max_random_saturation::int, optional, default='0'</code>: Augmentation Param: Maximum random value of S channel in HSL color space.</li>
<li><code>random_saturation_prob::float, optional, default=0</code>: Augmentation Param: Probability to apply random saturation.</li>
<li><code>max_random_illumination::int, optional, default='0'</code>: Augmentation Param: Maximum random value of L channel in HSL color space.</li>
<li><code>random_illumination_prob::float, optional, default=0</code>: Augmentation Param: Probability to apply random illumination.</li>
<li><code>max_random_contrast::float, optional, default=0</code>: Augmentation Param: Maximum random value of delta contrast.</li>
<li><code>random_contrast_prob::float, optional, default=0</code>: Augmentation Param: Probability to apply random contrast.</li>
<li><code>rand_mirror_prob::float, optional, default=0</code>: Augmentation Param: Probability to apply horizontal flip aka. mirror.</li>
<li><code>fill_value::int, optional, default='127'</code>: Augmentation Param: Filled color value while padding.</li>
<li><code>inter_method::int, optional, default='1'</code>: Augmentation Param: 0-NN 1-bilinear 2-cubic 3-area 4-lanczos4 9-auto 10-rand.</li>
<li><code>resize_mode::{'fit', 'force', 'shrink'},optional, default='force'</code>: Augmentation Param: How image data fit in data_shape. force: force reshape to data_shape regardless of aspect ratio; shrink: ensure each side fit in data_shape, preserve aspect ratio; fit: fit image to data_shape, preserve ratio, will upscale if applicable.</li>
<li><code>mean_img::string, optional, default=''</code>: Augmentation Param: Mean Image to be subtracted.</li>
<li><code>mean_r::float, optional, default=0</code>: Augmentation Param: Mean value on R channel.</li>
<li><code>mean_g::float, optional, default=0</code>: Augmentation Param: Mean value on G channel.</li>
<li><code>mean_b::float, optional, default=0</code>: Augmentation Param: Mean value on B channel.</li>
<li><code>mean_a::float, optional, default=0</code>: Augmentation Param: Mean value on Alpha channel.</li>
<li><code>std_r::float, optional, default=0</code>: Augmentation Param: Standard deviation on R channel.</li>
<li><code>std_g::float, optional, default=0</code>: Augmentation Param: Standard deviation on G channel.</li>
<li><code>std_b::float, optional, default=0</code>: Augmentation Param: Standard deviation on B channel.</li>
<li><code>std_a::float, optional, default=0</code>: Augmentation Param: Standard deviation on Alpha channel.</li>
<li><code>scale::float, optional, default=1</code>: Augmentation Param: Scale in color space.</li>
</ul>
<p>Returns the constructed <code>MXDataProvider</code>.</p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/1f50a144c90e5034af79468b0c9a9ff234a11b98/src/io.jl#L619-L747' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.ImageRecordIter-Tuple{}' href='#MXNet.mx.ImageRecordIter-Tuple{}'>#</a>
<strong><code>MXNet.mx.ImageRecordIter</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>ImageRecordIter(path_imglist, path_imgrec, path_imgidx, aug_seq, label_width, data_shape, preprocess_threads, verbose, num_parts, part_index, shuffle_chunk_size, shuffle_chunk_seed, shuffle, seed, verbose, batch_size, round_batch, prefetch_buffer, dtype, resize, rand_crop, max_rotate_angle, max_aspect_ratio, max_shear_ratio, max_crop_size, min_crop_size, max_random_scale, min_random_scale, max_img_size, min_img_size, random_h, random_s, random_l, rotate, fill_value, data_shape, inter_method, pad, seed, mirror, rand_mirror, mean_img, mean_r, mean_g, mean_b, mean_a, std_r, std_g, std_b, std_a, scale, max_random_contrast, max_random_illumination, verbose)
</code></pre>

<p>Can also be called with the alias <code>ImageRecordProvider</code>. Iterates on image RecordIO files</p>
<p>Reads batches of images from .rec RecordIO files. One can use $im2rec.py$ tool (in tools/) to pack raw image files into RecordIO files. This iterator is less flexible to customization but is fast and has lot of language bindings. To iterate over raw images directly use $ImageIter$ instead (in Python).</p>
<p>Example::</p>
<p>data_iter = mx.io.ImageRecordIter(     path_imgrec="./sample.rec", # The target record file.     data_shape=(3, 227, 227), # Output data shape; 227x227 region will be cropped from the original image.     batch_size=4, # Number of items per batch.     resize=256 # Resize the shorter edge to 256 before cropping.     # You can specify more augmentation options. Use help(mx.io.ImageRecordIter) to see all the options.     )</p>
<p><strong>You can now use the data_iter to access batches of images.</strong></p>
<p>batch = data_iter.next() # first batch.   images = batch.data[0] # This will contain 4 (=batch_size) images each of 3x227x227.</p>
<p><strong>process the images</strong></p>
<p>...   data_iter.reset() # To restart the iterator from the beginning.</p>
<p>Defined in src/io/iter_image_recordio_2.cc:L748</p>
<p><strong>Arguments:</strong></p>
<ul>
<li><code>data_name::Symbol</code>: keyword argument, default <code>:data</code>. The name of the data.</li>
<li><code>label_name::Symbol</code>: keyword argument, default <code>:softmax_label</code>. The name of the label. Could be <code>nothing</code> if no label is presented in this dataset.</li>
<li><code>path_imglist::string, optional, default=''</code>: Path to the image list (.lst) file. Generally created with tools/im2rec.py. Format (Tab separated): <index of record> <one or more labels>    <relative path from root folder>.</li>
<li><code>path_imgrec::string, optional, default=''</code>: Path to the image RecordIO (.rec) file or a directory path. Created with tools/im2rec.py.</li>
<li><code>path_imgidx::string, optional, default=''</code>: Path to the image RecordIO index (.idx) file. Created with tools/im2rec.py.</li>
<li><code>aug_seq::string, optional, default='aug_default'</code>: The augmenter names to represent sequence of augmenters to be applied, seperated by comma. Additional keyword parameters will be seen by these augmenters.</li>
<li><code>label_width::int, optional, default='1'</code>: The number of labels per image.</li>
<li><code>data_shape::Shape(tuple), required</code>: The shape of one output image in (channels, height, width) format.</li>
<li><code>preprocess_threads::int, optional, default='4'</code>: The number of threads to do preprocessing.</li>
<li><code>verbose::boolean, optional, default=1</code>: If or not output verbose information.</li>
<li><code>num_parts::int, optional, default='1'</code>: Virtually partition the data into these many parts.</li>
<li><code>part_index::int, optional, default='0'</code>: The <em>i</em>-th virtual partition to be read.</li>
<li><code>shuffle_chunk_size::long (non-negative), optional, default=0</code>: The data shuffle buffer size in MB. Only valid if shuffle is true.</li>
<li><code>shuffle_chunk_seed::int, optional, default='0'</code>: The random seed for shuffling</li>
<li><code>shuffle::boolean, optional, default=0</code>: Whether to shuffle data randomly or not.</li>
<li><code>seed::int, optional, default='0'</code>: The random seed.</li>
<li><code>batch_size::int (non-negative), required</code>: Batch size.</li>
<li><code>round_batch::boolean, optional, default=1</code>: Whether to use round robin to handle overflow batch or not.</li>
<li><code>prefetch_buffer::long (non-negative), optional, default=4</code>: Maximum number of batches to prefetch.</li>
<li><code>dtype::{None, 'float16', 'float32', 'float64', 'int32', 'uint8'},optional, default='None'</code>: Output data type. $None$ means no change.</li>
<li><code>resize::int, optional, default='-1'</code>: Down scale the shorter edge to a new size  before applying other augmentations.</li>
<li><code>rand_crop::boolean, optional, default=0</code>: If or not randomly crop the image</li>
<li><code>max_rotate_angle::int, optional, default='0'</code>: Rotate by a random degree in $[-v, v]$</li>
<li><code>max_aspect_ratio::float, optional, default=0</code>: Change the aspect (namely width/height) to a random value in $[1 - max_aspect_ratio, 1 + max_aspect_ratio]$</li>
<li><code>max_shear_ratio::float, optional, default=0</code>: Apply a shear transformation (namely $(x,y)-&gt;(x+my,y)$) with $m$ randomly chose from $[-max_shear_ratio, max_shear_ratio]$</li>
<li><code>max_crop_size::int, optional, default='-1'</code>: Crop both width and height into a random size in $[min_crop_size, max_crop_size]$</li>
<li><code>min_crop_size::int, optional, default='-1'</code>: Crop both width and height into a random size in $[min_crop_size, max_crop_size]$</li>
<li><code>max_random_scale::float, optional, default=1</code>: Resize into $[width<em>s, height</em>s]$ with $s$ randomly chosen from $[min_random_scale, max_random_scale]$</li>
<li><code>min_random_scale::float, optional, default=1</code>: Resize into $[width<em>s, height</em>s]$ with $s$ randomly chosen from $[min_random_scale, max_random_scale]$</li>
<li><code>max_img_size::float, optional, default=1e+10</code>: Set the maximal width and height after all resize and rotate argumentation  are applied</li>
<li><code>min_img_size::float, optional, default=0</code>: Set the minimal width and height after all resize and rotate argumentation  are applied</li>
<li><code>random_h::int, optional, default='0'</code>: Add a random value in $[-random_h, random_h]$ to the H channel in HSL color space.</li>
<li><code>random_s::int, optional, default='0'</code>: Add a random value in $[-random_s, random_s]$ to the S channel in HSL color space.</li>
<li><code>random_l::int, optional, default='0'</code>: Add a random value in $[-random_l, random_l]$ to the L channel in HSL color space.</li>
<li><code>rotate::int, optional, default='-1'</code>: Rotate by an angle. If set, it overwrites the $max_rotate_angle$ option.</li>
<li><code>fill_value::int, optional, default='255'</code>: Set the padding pixes value into $fill_value$.</li>
<li><code>inter_method::int, optional, default='1'</code>: The interpolation method: 0-NN 1-bilinear 2-cubic 3-area 4-lanczos4 9-auto 10-rand.</li>
<li><code>pad::int, optional, default='0'</code>: Change size from $[width, height]$ into $[pad + width + pad, pad + height + pad]$ by padding pixes</li>
<li><code>mirror::boolean, optional, default=0</code>: Whether to mirror the image or not. If true, images are flipped along the horizontal axis.</li>
<li><code>rand_mirror::boolean, optional, default=0</code>: Whether to randomly mirror images or not. If true, 50% of the images will be randomly mirrored (flipped along the horizontal axis)</li>
<li><code>mean_img::string, optional, default=''</code>: Filename of the mean image.</li>
<li><code>mean_r::float, optional, default=0</code>: The mean value to be subtracted on the R channel</li>
<li><code>mean_g::float, optional, default=0</code>: The mean value to be subtracted on the G channel</li>
<li><code>mean_b::float, optional, default=0</code>: The mean value to be subtracted on the B channel</li>
<li><code>mean_a::float, optional, default=0</code>: The mean value to be subtracted on the alpha channel</li>
<li><code>std_r::float, optional, default=1</code>: Augmentation Param: Standard deviation on R channel.</li>
<li><code>std_g::float, optional, default=1</code>: Augmentation Param: Standard deviation on G channel.</li>
<li><code>std_b::float, optional, default=1</code>: Augmentation Param: Standard deviation on B channel.</li>
<li><code>std_a::float, optional, default=1</code>: Augmentation Param: Standard deviation on Alpha channel.</li>
<li><code>scale::float, optional, default=1</code>: Multiply the image with a scale value.</li>
<li><code>max_random_contrast::float, optional, default=0</code>: Change the contrast with a value randomly chosen from $[-max_random_contrast, max_random_contrast]$</li>
<li><code>max_random_illumination::float, optional, default=0</code>: Change the illumination with a value randomly chosen from $[-max_random_illumination, max_random_illumination]$</li>
</ul>
<p>Returns the constructed <code>MXDataProvider</code>.</p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/1f50a144c90e5034af79468b0c9a9ff234a11b98/src/io.jl#L619-L754' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.ImageRecordIter_v1-Tuple{}' href='#MXNet.mx.ImageRecordIter_v1-Tuple{}'>#</a>
<strong><code>MXNet.mx.ImageRecordIter_v1</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>ImageRecordIter_v1(path_imglist, path_imgrec, path_imgidx, aug_seq, label_width, data_shape, preprocess_threads, verbose, num_parts, part_index, shuffle_chunk_size, shuffle_chunk_seed, shuffle, seed, verbose, batch_size, round_batch, prefetch_buffer, dtype, resize, rand_crop, max_rotate_angle, max_aspect_ratio, max_shear_ratio, max_crop_size, min_crop_size, max_random_scale, min_random_scale, max_img_size, min_img_size, random_h, random_s, random_l, rotate, fill_value, data_shape, inter_method, pad, seed, mirror, rand_mirror, mean_img, mean_r, mean_g, mean_b, mean_a, std_r, std_g, std_b, std_a, scale, max_random_contrast, max_random_illumination, verbose)
</code></pre>

<p>Iterating on image RecordIO files</p>
<p>Read images batches from RecordIO files with a rich of data augmentation options.</p>
<p>One can use $tools/im2rec.py$ to pack individual image files into RecordIO files.</p>
<p>Defined in src/io/iter_image_recordio.cc:L347</p>
<p><strong>Arguments:</strong></p>
<ul>
<li><code>data_name::Symbol</code>: keyword argument, default <code>:data</code>. The name of the data.</li>
<li><code>label_name::Symbol</code>: keyword argument, default <code>:softmax_label</code>. The name of the label. Could be <code>nothing</code> if no label is presented in this dataset.</li>
<li><code>path_imglist::string, optional, default=''</code>: Path to the image list (.lst) file. Generally created with tools/im2rec.py. Format (Tab separated): <index of record> <one or more labels>    <relative path from root folder>.</li>
<li><code>path_imgrec::string, optional, default=''</code>: Path to the image RecordIO (.rec) file or a directory path. Created with tools/im2rec.py.</li>
<li><code>path_imgidx::string, optional, default=''</code>: Path to the image RecordIO index (.idx) file. Created with tools/im2rec.py.</li>
<li><code>aug_seq::string, optional, default='aug_default'</code>: The augmenter names to represent sequence of augmenters to be applied, seperated by comma. Additional keyword parameters will be seen by these augmenters.</li>
<li><code>label_width::int, optional, default='1'</code>: The number of labels per image.</li>
<li><code>data_shape::Shape(tuple), required</code>: The shape of one output image in (channels, height, width) format.</li>
<li><code>preprocess_threads::int, optional, default='4'</code>: The number of threads to do preprocessing.</li>
<li><code>verbose::boolean, optional, default=1</code>: If or not output verbose information.</li>
<li><code>num_parts::int, optional, default='1'</code>: Virtually partition the data into these many parts.</li>
<li><code>part_index::int, optional, default='0'</code>: The <em>i</em>-th virtual partition to be read.</li>
<li><code>shuffle_chunk_size::long (non-negative), optional, default=0</code>: The data shuffle buffer size in MB. Only valid if shuffle is true.</li>
<li><code>shuffle_chunk_seed::int, optional, default='0'</code>: The random seed for shuffling</li>
<li><code>shuffle::boolean, optional, default=0</code>: Whether to shuffle data randomly or not.</li>
<li><code>seed::int, optional, default='0'</code>: The random seed.</li>
<li><code>batch_size::int (non-negative), required</code>: Batch size.</li>
<li><code>round_batch::boolean, optional, default=1</code>: Whether to use round robin to handle overflow batch or not.</li>
<li><code>prefetch_buffer::long (non-negative), optional, default=4</code>: Maximum number of batches to prefetch.</li>
<li><code>dtype::{None, 'float16', 'float32', 'float64', 'int32', 'uint8'},optional, default='None'</code>: Output data type. $None$ means no change.</li>
<li><code>resize::int, optional, default='-1'</code>: Down scale the shorter edge to a new size  before applying other augmentations.</li>
<li><code>rand_crop::boolean, optional, default=0</code>: If or not randomly crop the image</li>
<li><code>max_rotate_angle::int, optional, default='0'</code>: Rotate by a random degree in $[-v, v]$</li>
<li><code>max_aspect_ratio::float, optional, default=0</code>: Change the aspect (namely width/height) to a random value in $[1 - max_aspect_ratio, 1 + max_aspect_ratio]$</li>
<li><code>max_shear_ratio::float, optional, default=0</code>: Apply a shear transformation (namely $(x,y)-&gt;(x+my,y)$) with $m$ randomly chose from $[-max_shear_ratio, max_shear_ratio]$</li>
<li><code>max_crop_size::int, optional, default='-1'</code>: Crop both width and height into a random size in $[min_crop_size, max_crop_size]$</li>
<li><code>min_crop_size::int, optional, default='-1'</code>: Crop both width and height into a random size in $[min_crop_size, max_crop_size]$</li>
<li><code>max_random_scale::float, optional, default=1</code>: Resize into $[width<em>s, height</em>s]$ with $s$ randomly chosen from $[min_random_scale, max_random_scale]$</li>
<li><code>min_random_scale::float, optional, default=1</code>: Resize into $[width<em>s, height</em>s]$ with $s$ randomly chosen from $[min_random_scale, max_random_scale]$</li>
<li><code>max_img_size::float, optional, default=1e+10</code>: Set the maximal width and height after all resize and rotate argumentation  are applied</li>
<li><code>min_img_size::float, optional, default=0</code>: Set the minimal width and height after all resize and rotate argumentation  are applied</li>
<li><code>random_h::int, optional, default='0'</code>: Add a random value in $[-random_h, random_h]$ to the H channel in HSL color space.</li>
<li><code>random_s::int, optional, default='0'</code>: Add a random value in $[-random_s, random_s]$ to the S channel in HSL color space.</li>
<li><code>random_l::int, optional, default='0'</code>: Add a random value in $[-random_l, random_l]$ to the L channel in HSL color space.</li>
<li><code>rotate::int, optional, default='-1'</code>: Rotate by an angle. If set, it overwrites the $max_rotate_angle$ option.</li>
<li><code>fill_value::int, optional, default='255'</code>: Set the padding pixes value into $fill_value$.</li>
<li><code>inter_method::int, optional, default='1'</code>: The interpolation method: 0-NN 1-bilinear 2-cubic 3-area 4-lanczos4 9-auto 10-rand.</li>
<li><code>pad::int, optional, default='0'</code>: Change size from $[width, height]$ into $[pad + width + pad, pad + height + pad]$ by padding pixes</li>
<li><code>mirror::boolean, optional, default=0</code>: Whether to mirror the image or not. If true, images are flipped along the horizontal axis.</li>
<li><code>rand_mirror::boolean, optional, default=0</code>: Whether to randomly mirror images or not. If true, 50% of the images will be randomly mirrored (flipped along the horizontal axis)</li>
<li><code>mean_img::string, optional, default=''</code>: Filename of the mean image.</li>
<li><code>mean_r::float, optional, default=0</code>: The mean value to be subtracted on the R channel</li>
<li><code>mean_g::float, optional, default=0</code>: The mean value to be subtracted on the G channel</li>
<li><code>mean_b::float, optional, default=0</code>: The mean value to be subtracted on the B channel</li>
<li><code>mean_a::float, optional, default=0</code>: The mean value to be subtracted on the alpha channel</li>
<li><code>std_r::float, optional, default=1</code>: Augmentation Param: Standard deviation on R channel.</li>
<li><code>std_g::float, optional, default=1</code>: Augmentation Param: Standard deviation on G channel.</li>
<li><code>std_b::float, optional, default=1</code>: Augmentation Param: Standard deviation on B channel.</li>
<li><code>std_a::float, optional, default=1</code>: Augmentation Param: Standard deviation on Alpha channel.</li>
<li><code>scale::float, optional, default=1</code>: Multiply the image with a scale value.</li>
<li><code>max_random_contrast::float, optional, default=0</code>: Change the contrast with a value randomly chosen from $[-max_random_contrast, max_random_contrast]$</li>
<li><code>max_random_illumination::float, optional, default=0</code>: Change the illumination with a value randomly chosen from $[-max_random_illumination, max_random_illumination]$</li>
</ul>
<p>Returns the constructed <code>MXDataProvider</code>.</p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/1f50a144c90e5034af79468b0c9a9ff234a11b98/src/io.jl#L619-L738' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.ImageRecordUInt8Iter-Tuple{}' href='#MXNet.mx.ImageRecordUInt8Iter-Tuple{}'>#</a>
<strong><code>MXNet.mx.ImageRecordUInt8Iter</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>ImageRecordUInt8Iter(path_imglist, path_imgrec, path_imgidx, aug_seq, label_width, data_shape, preprocess_threads, verbose, num_parts, part_index, shuffle_chunk_size, shuffle_chunk_seed, shuffle, seed, verbose, batch_size, round_batch, prefetch_buffer, dtype, resize, rand_crop, max_rotate_angle, max_aspect_ratio, max_shear_ratio, max_crop_size, min_crop_size, max_random_scale, min_random_scale, max_img_size, min_img_size, random_h, random_s, random_l, rotate, fill_value, data_shape, inter_method, pad)
</code></pre>

<p>Can also be called with the alias <code>ImageRecordUInt8Provider</code>. Iterating on image RecordIO files</p>
<p>This iterator is identical to $ImageRecordIter$ except for using $uint8$ as the data type instead of $float$.</p>
<p>Defined in src/io/iter_image_recordio_2.cc:L765</p>
<p><strong>Arguments:</strong></p>
<ul>
<li><code>data_name::Symbol</code>: keyword argument, default <code>:data</code>. The name of the data.</li>
<li><code>label_name::Symbol</code>: keyword argument, default <code>:softmax_label</code>. The name of the label. Could be <code>nothing</code> if no label is presented in this dataset.</li>
<li><code>path_imglist::string, optional, default=''</code>: Path to the image list (.lst) file. Generally created with tools/im2rec.py. Format (Tab separated): <index of record> <one or more labels>    <relative path from root folder>.</li>
<li><code>path_imgrec::string, optional, default=''</code>: Path to the image RecordIO (.rec) file or a directory path. Created with tools/im2rec.py.</li>
<li><code>path_imgidx::string, optional, default=''</code>: Path to the image RecordIO index (.idx) file. Created with tools/im2rec.py.</li>
<li><code>aug_seq::string, optional, default='aug_default'</code>: The augmenter names to represent sequence of augmenters to be applied, seperated by comma. Additional keyword parameters will be seen by these augmenters.</li>
<li><code>label_width::int, optional, default='1'</code>: The number of labels per image.</li>
<li><code>data_shape::Shape(tuple), required</code>: The shape of one output image in (channels, height, width) format.</li>
<li><code>preprocess_threads::int, optional, default='4'</code>: The number of threads to do preprocessing.</li>
<li><code>verbose::boolean, optional, default=1</code>: If or not output verbose information.</li>
<li><code>num_parts::int, optional, default='1'</code>: Virtually partition the data into these many parts.</li>
<li><code>part_index::int, optional, default='0'</code>: The <em>i</em>-th virtual partition to be read.</li>
<li><code>shuffle_chunk_size::long (non-negative), optional, default=0</code>: The data shuffle buffer size in MB. Only valid if shuffle is true.</li>
<li><code>shuffle_chunk_seed::int, optional, default='0'</code>: The random seed for shuffling</li>
<li><code>shuffle::boolean, optional, default=0</code>: Whether to shuffle data randomly or not.</li>
<li><code>seed::int, optional, default='0'</code>: The random seed.</li>
<li><code>batch_size::int (non-negative), required</code>: Batch size.</li>
<li><code>round_batch::boolean, optional, default=1</code>: Whether to use round robin to handle overflow batch or not.</li>
<li><code>prefetch_buffer::long (non-negative), optional, default=4</code>: Maximum number of batches to prefetch.</li>
<li><code>dtype::{None, 'float16', 'float32', 'float64', 'int32', 'uint8'},optional, default='None'</code>: Output data type. $None$ means no change.</li>
<li><code>resize::int, optional, default='-1'</code>: Down scale the shorter edge to a new size  before applying other augmentations.</li>
<li><code>rand_crop::boolean, optional, default=0</code>: If or not randomly crop the image</li>
<li><code>max_rotate_angle::int, optional, default='0'</code>: Rotate by a random degree in $[-v, v]$</li>
<li><code>max_aspect_ratio::float, optional, default=0</code>: Change the aspect (namely width/height) to a random value in $[1 - max_aspect_ratio, 1 + max_aspect_ratio]$</li>
<li><code>max_shear_ratio::float, optional, default=0</code>: Apply a shear transformation (namely $(x,y)-&gt;(x+my,y)$) with $m$ randomly chose from $[-max_shear_ratio, max_shear_ratio]$</li>
<li><code>max_crop_size::int, optional, default='-1'</code>: Crop both width and height into a random size in $[min_crop_size, max_crop_size]$</li>
<li><code>min_crop_size::int, optional, default='-1'</code>: Crop both width and height into a random size in $[min_crop_size, max_crop_size]$</li>
<li><code>max_random_scale::float, optional, default=1</code>: Resize into $[width<em>s, height</em>s]$ with $s$ randomly chosen from $[min_random_scale, max_random_scale]$</li>
<li><code>min_random_scale::float, optional, default=1</code>: Resize into $[width<em>s, height</em>s]$ with $s$ randomly chosen from $[min_random_scale, max_random_scale]$</li>
<li><code>max_img_size::float, optional, default=1e+10</code>: Set the maximal width and height after all resize and rotate argumentation  are applied</li>
<li><code>min_img_size::float, optional, default=0</code>: Set the minimal width and height after all resize and rotate argumentation  are applied</li>
<li><code>random_h::int, optional, default='0'</code>: Add a random value in $[-random_h, random_h]$ to the H channel in HSL color space.</li>
<li><code>random_s::int, optional, default='0'</code>: Add a random value in $[-random_s, random_s]$ to the S channel in HSL color space.</li>
<li><code>random_l::int, optional, default='0'</code>: Add a random value in $[-random_l, random_l]$ to the L channel in HSL color space.</li>
<li><code>rotate::int, optional, default='-1'</code>: Rotate by an angle. If set, it overwrites the $max_rotate_angle$ option.</li>
<li><code>fill_value::int, optional, default='255'</code>: Set the padding pixes value into $fill_value$.</li>
<li><code>inter_method::int, optional, default='1'</code>: The interpolation method: 0-NN 1-bilinear 2-cubic 3-area 4-lanczos4 9-auto 10-rand.</li>
<li><code>pad::int, optional, default='0'</code>: Change size from $[width, height]$ into $[pad + width + pad, pad + height + pad]$ by padding pixes</li>
</ul>
<p>Returns the constructed <code>MXDataProvider</code>.</p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/1f50a144c90e5034af79468b0c9a9ff234a11b98/src/io.jl#L619-L708' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.ImageRecordUInt8Iter_v1-Tuple{}' href='#MXNet.mx.ImageRecordUInt8Iter_v1-Tuple{}'>#</a>
<strong><code>MXNet.mx.ImageRecordUInt8Iter_v1</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>ImageRecordUInt8Iter_v1(path_imglist, path_imgrec, path_imgidx, aug_seq, label_width, data_shape, preprocess_threads, verbose, num_parts, part_index, shuffle_chunk_size, shuffle_chunk_seed, shuffle, seed, verbose, batch_size, round_batch, prefetch_buffer, dtype, resize, rand_crop, max_rotate_angle, max_aspect_ratio, max_shear_ratio, max_crop_size, min_crop_size, max_random_scale, min_random_scale, max_img_size, min_img_size, random_h, random_s, random_l, rotate, fill_value, data_shape, inter_method, pad)
</code></pre>

<p>Iterating on image RecordIO files</p>
<p>This iterator is identical to $ImageRecordIter$ except for using $uint8$ as the data type instead of $float$.</p>
<p>Defined in src/io/iter_image_recordio.cc:L368</p>
<p><strong>Arguments:</strong></p>
<ul>
<li><code>data_name::Symbol</code>: keyword argument, default <code>:data</code>. The name of the data.</li>
<li><code>label_name::Symbol</code>: keyword argument, default <code>:softmax_label</code>. The name of the label. Could be <code>nothing</code> if no label is presented in this dataset.</li>
<li><code>path_imglist::string, optional, default=''</code>: Path to the image list (.lst) file. Generally created with tools/im2rec.py. Format (Tab separated): <index of record> <one or more labels>    <relative path from root folder>.</li>
<li><code>path_imgrec::string, optional, default=''</code>: Path to the image RecordIO (.rec) file or a directory path. Created with tools/im2rec.py.</li>
<li><code>path_imgidx::string, optional, default=''</code>: Path to the image RecordIO index (.idx) file. Created with tools/im2rec.py.</li>
<li><code>aug_seq::string, optional, default='aug_default'</code>: The augmenter names to represent sequence of augmenters to be applied, seperated by comma. Additional keyword parameters will be seen by these augmenters.</li>
<li><code>label_width::int, optional, default='1'</code>: The number of labels per image.</li>
<li><code>data_shape::Shape(tuple), required</code>: The shape of one output image in (channels, height, width) format.</li>
<li><code>preprocess_threads::int, optional, default='4'</code>: The number of threads to do preprocessing.</li>
<li><code>verbose::boolean, optional, default=1</code>: If or not output verbose information.</li>
<li><code>num_parts::int, optional, default='1'</code>: Virtually partition the data into these many parts.</li>
<li><code>part_index::int, optional, default='0'</code>: The <em>i</em>-th virtual partition to be read.</li>
<li><code>shuffle_chunk_size::long (non-negative), optional, default=0</code>: The data shuffle buffer size in MB. Only valid if shuffle is true.</li>
<li><code>shuffle_chunk_seed::int, optional, default='0'</code>: The random seed for shuffling</li>
<li><code>shuffle::boolean, optional, default=0</code>: Whether to shuffle data randomly or not.</li>
<li><code>seed::int, optional, default='0'</code>: The random seed.</li>
<li><code>batch_size::int (non-negative), required</code>: Batch size.</li>
<li><code>round_batch::boolean, optional, default=1</code>: Whether to use round robin to handle overflow batch or not.</li>
<li><code>prefetch_buffer::long (non-negative), optional, default=4</code>: Maximum number of batches to prefetch.</li>
<li><code>dtype::{None, 'float16', 'float32', 'float64', 'int32', 'uint8'},optional, default='None'</code>: Output data type. $None$ means no change.</li>
<li><code>resize::int, optional, default='-1'</code>: Down scale the shorter edge to a new size  before applying other augmentations.</li>
<li><code>rand_crop::boolean, optional, default=0</code>: If or not randomly crop the image</li>
<li><code>max_rotate_angle::int, optional, default='0'</code>: Rotate by a random degree in $[-v, v]$</li>
<li><code>max_aspect_ratio::float, optional, default=0</code>: Change the aspect (namely width/height) to a random value in $[1 - max_aspect_ratio, 1 + max_aspect_ratio]$</li>
<li><code>max_shear_ratio::float, optional, default=0</code>: Apply a shear transformation (namely $(x,y)-&gt;(x+my,y)$) with $m$ randomly chose from $[-max_shear_ratio, max_shear_ratio]$</li>
<li><code>max_crop_size::int, optional, default='-1'</code>: Crop both width and height into a random size in $[min_crop_size, max_crop_size]$</li>
<li><code>min_crop_size::int, optional, default='-1'</code>: Crop both width and height into a random size in $[min_crop_size, max_crop_size]$</li>
<li><code>max_random_scale::float, optional, default=1</code>: Resize into $[width<em>s, height</em>s]$ with $s$ randomly chosen from $[min_random_scale, max_random_scale]$</li>
<li><code>min_random_scale::float, optional, default=1</code>: Resize into $[width<em>s, height</em>s]$ with $s$ randomly chosen from $[min_random_scale, max_random_scale]$</li>
<li><code>max_img_size::float, optional, default=1e+10</code>: Set the maximal width and height after all resize and rotate argumentation  are applied</li>
<li><code>min_img_size::float, optional, default=0</code>: Set the minimal width and height after all resize and rotate argumentation  are applied</li>
<li><code>random_h::int, optional, default='0'</code>: Add a random value in $[-random_h, random_h]$ to the H channel in HSL color space.</li>
<li><code>random_s::int, optional, default='0'</code>: Add a random value in $[-random_s, random_s]$ to the S channel in HSL color space.</li>
<li><code>random_l::int, optional, default='0'</code>: Add a random value in $[-random_l, random_l]$ to the L channel in HSL color space.</li>
<li><code>rotate::int, optional, default='-1'</code>: Rotate by an angle. If set, it overwrites the $max_rotate_angle$ option.</li>
<li><code>fill_value::int, optional, default='255'</code>: Set the padding pixes value into $fill_value$.</li>
<li><code>inter_method::int, optional, default='1'</code>: The interpolation method: 0-NN 1-bilinear 2-cubic 3-area 4-lanczos4 9-auto 10-rand.</li>
<li><code>pad::int, optional, default='0'</code>: Change size from $[width, height]$ into $[pad + width + pad, pad + height + pad]$ by padding pixes</li>
</ul>
<p>Returns the constructed <code>MXDataProvider</code>.</p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/1f50a144c90e5034af79468b0c9a9ff234a11b98/src/io.jl#L619-L707' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.LibSVMIter-Tuple{}' href='#MXNet.mx.LibSVMIter-Tuple{}'>#</a>
<strong><code>MXNet.mx.LibSVMIter</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>LibSVMIter(data_libsvm, data_shape, label_libsvm, label_shape, num_parts, part_index, batch_size, round_batch, prefetch_buffer, dtype)
</code></pre>

<p>Can also be called with the alias <code>LibSVMProvider</code>. Returns the LibSVM iterator which returns data with <code>csr</code> storage type. This iterator is experimental and should be used with care.</p>
<p>The input data is stored in a format similar to LibSVM file format, except that the <strong>indices are expected to be zero-based instead of one-based, and the column indices for each row are expected to be sorted in ascending order</strong>. Details of the LibSVM format are available <code>here. &lt;https://www.csie.ntu.edu.tw/~cjlin/libsvmtools/datasets/&gt;</code>_</p>
<p>The <code>data_shape</code> parameter is used to set the shape of each line of the data. The dimension of both <code>data_shape</code> and <code>label_shape</code> are expected to be 1.</p>
<p>The <code>data_libsvm</code> parameter is used to set the path input LibSVM file. When it is set to a directory, all the files in the directory will be read.</p>
<p>When <code>label_libsvm</code> is set to $NULL$, both data and label are read from the file specified by <code>data_libsvm</code>. In this case, the data is stored in <code>csr</code> storage type, while the label is a 1D dense array.</p>
<p>The <code>LibSVMIter</code> only support <code>round_batch</code> parameter set to $True$. Therefore, if <code>batch_size</code> is 3 and there are 4 total rows in libsvm file, 2 more examples are consumed at the first round.</p>
<p>When <code>num_parts</code> and <code>part_index</code> are provided, the data is split into <code>num_parts</code> partitions, and the iterator only reads the <code>part_index</code>-th partition. However, the partitions are not guaranteed to be even.</p>
<p>$reset()$ is expected to be called only after a complete pass of data.</p>
<p>Example::</p>
<p><strong>Contents of libsvm file $data.t$.</strong></p>
<p>1.0 0:0.5 2:1.2   -2.0   -3.0 0:0.6 1:2.4 2:1.2   4 2:-1.2</p>
<p><strong>Creates a <code>LibSVMIter</code> with <code>batch_size</code>=3.</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>data_iter = mx.io.LibSVMIter(data_libsvm = 'data.t', data_shape = (3,), batch_size = 3)</p>
</blockquote>
</blockquote>
</blockquote>
<p><strong>The data of the first batch is stored in csr storage type</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>batch = data_iter.next() csr = batch.data[0]</p>
</blockquote>
</blockquote>
</blockquote>
<p><CSRNDArray 3x3 @cpu(0)></p>
<blockquote>
<blockquote>
<blockquote>
<p>csr.asnumpy()</p>
</blockquote>
</blockquote>
</blockquote>
<p>[[ 0.5        0.          1.2 ]   [ 0.          0.          0.  ]   [ 0.6         2.4         1.2]]</p>
<p><strong>The label of first batch</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>label = batch.label[0] label</p>
</blockquote>
</blockquote>
</blockquote>
<p>[ 1. -2. -3.]   <NDArray 3 @cpu(0)></p>
<blockquote>
<blockquote>
<blockquote>
<p>second_batch = data_iter.next()</p>
</blockquote>
</blockquote>
</blockquote>
<p><strong>The data of the second batch</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>second_batch.data[0].asnumpy()</p>
</blockquote>
</blockquote>
</blockquote>
<p>[[ 0.          0.         -1.2 ]    [ 0.5         0.          1.2 ]    [ 0.          0.          0. ]]</p>
<p><strong>The label of the second batch</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>second_batch.label[0].asnumpy()</p>
</blockquote>
</blockquote>
</blockquote>
<p>[ 4.  1. -2.]</p>
<blockquote>
<blockquote>
<blockquote>
<p>data_iter.reset()</p>
</blockquote>
</blockquote>
</blockquote>
<p><strong>To restart the iterator for the second pass of the data</strong></p>
<p>When <code>label_libsvm</code> is set to the path to another LibSVM file, data is read from <code>data_libsvm</code> and label from <code>label_libsvm</code>. In this case, both data and label are stored in the csr format. If the label column in the <code>data_libsvm</code> file is ignored.</p>
<p>Example::</p>
<p><strong>Contents of libsvm file $label.t$</strong></p>
<p>1.0   -2.0 0:0.125   -3.0 2:1.2   4 1:1.0 2:-1.2</p>
<p><strong>Creates a <code>LibSVMIter</code> with specified label file</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>data_iter = mx.io.LibSVMIter(data_libsvm = 'data.t', data_shape = (3,),</p>
</blockquote>
</blockquote>
</blockquote>
<pre><code>               label_libsvm = 'label.t', label_shape = (3,), batch_size = 3)
</code></pre>

<p><strong>Both data and label are in csr storage type</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>batch = data_iter.next() csr_data = batch.data[0]</p>
</blockquote>
</blockquote>
</blockquote>
<p><CSRNDArray 3x3 @cpu(0)></p>
<blockquote>
<blockquote>
<blockquote>
<p>csr_data.asnumpy()</p>
</blockquote>
</blockquote>
</blockquote>
<p>[[ 0.5         0.          1.2  ]    [ 0.          0.          0.   ]    [ 0.6         2.4         1.2 ]]</p>
<blockquote>
<blockquote>
<blockquote>
<p>csr_label = batch.label[0]</p>
</blockquote>
</blockquote>
</blockquote>
<p><CSRNDArray 3x3 @cpu(0)></p>
<blockquote>
<blockquote>
<blockquote>
<p>csr_label.asnumpy()</p>
</blockquote>
</blockquote>
</blockquote>
<p>[[ 0.          0.          0.   ]    [ 0.125       0.          0.   ]    [ 0.          0.          1.2 ]]</p>
<p>Defined in src/io/iter_libsvm.cc:L298</p>
<p><strong>Arguments:</strong></p>
<ul>
<li><code>data_name::Symbol</code>: keyword argument, default <code>:data</code>. The name of the data.</li>
<li><code>label_name::Symbol</code>: keyword argument, default <code>:softmax_label</code>. The name of the label. Could be <code>nothing</code> if no label is presented in this dataset.</li>
<li><code>data_libsvm::string, required</code>: The input zero-base indexed LibSVM data file or a directory path.</li>
<li><code>data_shape::Shape(tuple), required</code>: The shape of one example.</li>
<li><code>label_libsvm::string, optional, default='NULL'</code>: The input LibSVM label file or a directory path. If NULL, all labels will be read from $data_libsvm$.</li>
<li><code>label_shape::Shape(tuple), optional, default=[1]</code>: The shape of one label.</li>
<li><code>num_parts::int, optional, default='1'</code>: partition the data into multiple parts</li>
<li><code>part_index::int, optional, default='0'</code>: the index of the part will read</li>
<li><code>batch_size::int (non-negative), required</code>: Batch size.</li>
<li><code>round_batch::boolean, optional, default=1</code>: Whether to use round robin to handle overflow batch or not.</li>
<li><code>prefetch_buffer::long (non-negative), optional, default=4</code>: Maximum number of batches to prefetch.</li>
<li><code>dtype::{None, 'float16', 'float32', 'float64', 'int32', 'uint8'},optional, default='None'</code>: Output data type. $None$ means no change.</li>
</ul>
<p>Returns the constructed <code>MXDataProvider</code>.</p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/1f50a144c90e5034af79468b0c9a9ff234a11b98/src/io.jl#L619-L748' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.MNISTIter-Tuple{}' href='#MXNet.mx.MNISTIter-Tuple{}'>#</a>
<strong><code>MXNet.mx.MNISTIter</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>MNISTIter(image, label, batch_size, shuffle, flat, seed, silent, num_parts, part_index, prefetch_buffer, dtype)
</code></pre>

<p>Can also be called with the alias <code>MNISTProvider</code>. Iterating on the MNIST dataset.</p>
<p>One can download the dataset from http://yann.lecun.com/exdb/mnist/</p>
<p>Defined in src/io/iter_mnist.cc:L265</p>
<p><strong>Arguments:</strong></p>
<ul>
<li><code>data_name::Symbol</code>: keyword argument, default <code>:data</code>. The name of the data.</li>
<li><code>label_name::Symbol</code>: keyword argument, default <code>:softmax_label</code>. The name of the label. Could be <code>nothing</code> if no label is presented in this dataset.</li>
<li><code>image::string, optional, default='./train-images-idx3-ubyte'</code>: Dataset Param: Mnist image path.</li>
<li><code>label::string, optional, default='./train-labels-idx1-ubyte'</code>: Dataset Param: Mnist label path.</li>
<li><code>batch_size::int, optional, default='128'</code>: Batch Param: Batch Size.</li>
<li><code>shuffle::boolean, optional, default=1</code>: Augmentation Param: Whether to shuffle data.</li>
<li><code>flat::boolean, optional, default=0</code>: Augmentation Param: Whether to flat the data into 1D.</li>
<li><code>seed::int, optional, default='0'</code>: Augmentation Param: Random Seed.</li>
<li><code>silent::boolean, optional, default=0</code>: Auxiliary Param: Whether to print out data info.</li>
<li><code>num_parts::int, optional, default='1'</code>: partition the data into multiple parts</li>
<li><code>part_index::int, optional, default='0'</code>: the index of the part will read</li>
<li><code>prefetch_buffer::long (non-negative), optional, default=4</code>: Maximum number of batches to prefetch.</li>
<li><code>dtype::{None, 'float16', 'float32', 'float64', 'int32', 'uint8'},optional, default='None'</code>: Output data type. $None$ means no change.</li>
</ul>
<p>Returns the constructed <code>MXDataProvider</code>.</p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/1f50a144c90e5034af79468b0c9a9ff234a11b98/src/io.jl#L619-L657' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.eachbatch-Tuple{MXNet.mx.AbstractDataProvider}' href='#MXNet.mx.eachbatch-Tuple{MXNet.mx.AbstractDataProvider}'>#</a>
<strong><code>MXNet.mx.eachbatch</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>eachbatch(provider::AbstractDataProvider)
</code></pre>

<p>Allows you to perform operations on data every epoch. This is especially useful when you need to perform real-time augmentation of the data. </p>
<p><strong>Arguments:</strong></p>
<ul>
<li><code>provider</code>: an instance of the custom DataProvider type. You must return this</li>
</ul>
<p>instance after modifying its fields.</p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/1f50a144c90e5034af79468b0c9a9ff234a11b98/src/io.jl#L215-L225' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.load_data!-Tuple{MXNet.mx.AbstractDataProvider,MXNet.mx.AbstractDataBatch,Array{Array{Tuple{UnitRange{Int64},MXNet.mx.NDArray},1},1}}' href='#MXNet.mx.load_data!-Tuple{MXNet.mx.AbstractDataProvider,MXNet.mx.AbstractDataBatch,Array{Array{Tuple{UnitRange{Int64},MXNet.mx.NDArray},1},1}}'>#</a>
<strong><code>MXNet.mx.load_data!</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>load_data!(provider, batch, targets)
</code></pre>

<p><strong>Arguments:</strong></p>
<ul>
<li><code>provider::AbstractDataProvider</code>: the data provider.</li>
<li><code>batch::AbstractDataBatch</code>: the data batch object.</li>
<li><code>targets::Vector{Vector{SlicedNDArray}}</code>: the targets to load data into.</li>
</ul>
<p>The targets is a list of the same length as number of data provided by this provider. Each element in the list is a list of <code>SlicedNDArray</code>. This list described a spliting scheme of this data batch into different slices, each slice is specified by a slice-ndarray pair, where <em>slice</em> specify the range of samples in the mini-batch that should be loaded into the corresponding <em>ndarray</em>.</p>
<p>This utility function is used in data parallelization, where a mini-batch is splited and computed on several different devices.</p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/1f50a144c90e5034af79468b0c9a9ff234a11b98/src/io.jl#L142-L158' class='documenter-source'>source</a><br></p>
<p><a id='MXNet.mx.load_label!-Tuple{MXNet.mx.AbstractDataProvider,MXNet.mx.AbstractDataBatch,Array{Array{Tuple{UnitRange{Int64},MXNet.mx.NDArray},1},1}}' href='#MXNet.mx.load_label!-Tuple{MXNet.mx.AbstractDataProvider,MXNet.mx.AbstractDataBatch,Array{Array{Tuple{UnitRange{Int64},MXNet.mx.NDArray},1},1}}'>#</a>
<strong><code>MXNet.mx.load_label!</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>load_label!(provider, batch, targets)
</code></pre>

<ul>
<li><code>provider::AbstractDataProvider provider</code>: the data provider.</li>
<li><code>batch::AbstractDataBatch batch</code>: the data batch object.</li>
<li><code>targets::Vector{Vector{SlicedNDArray}}</code>: the targets to load label into.</li>
</ul>
<p>The same as <a href="./#MXNet.mx.load_data!"><code>load_data!</code></a>, except that this is for loading labels.</p>
<p><a target='_blank' href='https://github.com/dmlc/MXNet.jl/blob/1f50a144c90e5034af79468b0c9a9ff234a11b98/src/io.jl#L164-L172' class='documenter-source'>source</a><br></p>
                
                  
                
              
              
                
              
            </article>
          </div>
        </div>
      </main>
      
        
<footer class="md-footer">
  
    <div class="md-footer-nav">
      <nav class="md-footer-nav__inner md-grid">
        
          <a href="../metric/" title="Evaluation Metrics" class="md-flex md-footer-nav__link md-footer-nav__link--prev" rel="prev">
            <div class="md-flex__cell md-flex__cell--shrink">
              <i class="md-icon md-icon--arrow-back md-footer-nav__button"></i>
            </div>
            <div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
              <span class="md-flex__ellipsis">
                <span class="md-footer-nav__direction">
                  Previous
                </span>
                Evaluation Metrics
              </span>
            </div>
          </a>
        
        
          <a href="../ndarray/" title="NDArray API" class="md-flex md-footer-nav__link md-footer-nav__link--next" rel="next">
            <div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
              <span class="md-flex__ellipsis">
                <span class="md-footer-nav__direction">
                  Next
                </span>
                NDArray API
              </span>
            </div>
            <div class="md-flex__cell md-flex__cell--shrink">
              <i class="md-icon md-icon--arrow-forward md-footer-nav__button"></i>
            </div>
          </a>
        
      </nav>
    </div>
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
        powered by
        <a href="http://www.mkdocs.org">MkDocs</a>
        and
        <a href="https://squidfunk.github.io/mkdocs-material/">
          Material for MkDocs</a>
      </div>
      
        
      
    </div>
  </div>
</footer>
      
    </div>
    
      <script src="../../assets/javascripts/application-a5397a53ce.js"></script>
      
      <script>app.initialize({version:"0.17.2",url:{base:"../.."}})</script>
      
        <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
      
        <script src="../../assets/mathjaxhelper.js"></script>
      
    
    
      
    
  </body>
</html>